% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lassoBagAddGPD.R
\name{Lasso.bag}
\alias{Lasso.bag}
\title{LASSO-bagging
a lasso based variable selecting CART framework}
\usage{
Lasso.bag(mat, out.mat, base.exist = F, bootN = 1000, imputeN = 1000,
  imputeN.max = 2000, permut.increase = 100, boot.rep = TRUE,
  a.family = c("gaussian", "binomial", "poisson", "multinomial", "cox",
  "mgaussian"), parallel = F, fit.pareto = "mle", permutation = TRUE,
  n.cores = 1, rd.seed = 89757, plot.freq = "full", plot.out = F,
  use.gpd = F, do.plot = F)
}
\arguments{
\item{mat}{sample matrix that each column represent a variable and rows represent sample data points, all the entries in it should be numeric.}

\item{out.mat}{vector or dataframe with two columns with the same length as the sample size from `mat`}

\item{base.exist}{indicates whether we have an existed frequency data frame. We set it to be FALSE under most condition. If you don't know what it means, leave it to be FALSE(default)}

\item{bootN}{the size of resampled sample, only valid when permutation set to TRUE}

\item{imputeN}{the initial permutation times, only valid when permutation set to TRUE}

\item{imputeN.max}{the max permutation times. Regardless of whether p has meet the requirement,, only valid when permutation set to TRUE}

\item{permut.increase}{if the initial imputeN times of permutation doesn't meet the requirement, then we add â€˜permut.increase times of permutation??? to get more random/permutation values, only valid when permutation set to TRUE}

\item{boot.rep}{whether :"sampling with return" or not, only valid when permutation set to TRUE}

\item{a.family}{a string vector to determine the data type of out.mat}

\item{parallel}{whether the script run in parallel, you need to set n.cores in case this package conquers all your cpu resource}

\item{fit.pareto}{the method of fitting Generalized Pareto Distribution, alternative choice is "gd", for gradient descend}

\item{permutation}{to decide whether to do permutation test, if set FALSE, no p value returns}

\item{n.cores}{how many cores/process to be assigned for this function, in Windows, you have to set this to 1}

\item{rd.seed}{it is the random seed of this function, in case some of the experiments need to be reappeared}

\item{plot.freq}{whether to show all the non-zero frequency in the final barplot or not. If "full", all the features(including zero frequency) will be plotted. If "part", all the non-zero features will be plotted. If "not", will not print the plot.}

\item{plot.out}{the path or file's name to save the plot. If set to FALSE, no plot will be output. If you run this function in Linux command line, you don't have to set this param for the plot.freq will output your plot to your current working directory with name "Rplot.pdf".Default to FALSE.}

\item{do.plot}{whether to print a barplot to show the frequency of the output. This package will show you a barplot when it is TRUE. If it is FALSE, the two plot.* params above will be invalid then.}
}
\value{
a dataframe that contains the frequency, the p value and the adjusted p value of each feature(if you set permutation=T)
}
\description{
LASSO-bagging
a lasso based variable selecting CART framework
}
\examples{
require(glmnet)
require(POT)
require(parallel)
require(ggplot2)

df <- df.test # this is the integrated data of this package
# change those improper format in df
to.numeric1 <- as.character(df$riskscoreStatus)
to.numeric2 <- as.character(df$LeftOrRight)
to.numeric3 <- as.character(df$Sex)
to.numeric1[which(to.numeric1=="Low")] <- 0
to.numeric1[which(to.numeric1=="High")] <- 1
to.numeric2[which(to.numeric2=="Left")] <- 0
to.numeric2[which(to.numeric2=="Right")] <- 1
to.numeric3[which(to.numeric3=="Female")] <- 0
to.numeric3[which(to.numeric3=="Male")] <- 1
df$riskscoreStatus <- to.numeric1
df$LeftOrRight <- to.numeric2
df$Sex <- to.numeric3
rownames(df) <- df$ID
df <- df[,which(colnames(df)!="ID")]

x <- df[,which(!colnames(df) \%in\% c("Sex","Age","Osstatus","DFSstatus","OS","DFS","LeftOrRight","LymStatus","NI","VI","Stage","remove","riskscore","riskscoreStatus","ageStatus"))]

# cox
y <- df[,which(colnames(df) \%in\% c("Osstatus","OS"))]
y <- y[,c(2,1)]
colnames(y) <- c("time","status")
m<-Lasso.bag(x,y,bootN=3,imputeN=5,imputeN.max = 7,permut.increase = 1,boot.rep = T,a.family = "cox",parallel=F)

# binomial
y <- df$riskscoreStatus
m<-Lasso.bag(x,y,bootN=3,imputeN=5,imputeN.max = 7,permut.increase = 1,boot.rep = T,a.family = "binomial",parallel=F)

# gaussian
y <- df$riskscore
m<-Lasso.bag(x,y,bootN=3,imputeN=5,imputeN.max = 7,permut.increase = 1,boot.rep = T,a.family = "gaussian",parallel=F)

# if you don't need the result of permutation
m<-Lasso.bag(x,y,bootN=3,imputeN=5,imputeN.max = 7,permut.increase = 1,boot.rep = T,a.family = "gaussian",parallel=F,permutation=FALSE)
}
